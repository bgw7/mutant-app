// Package httpclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package httpclient

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Currency defines model for Currency.
type Currency struct {
	Code         string  `json:"code"`
	Name         string  `json:"name"`
	Symbol       *string `json:"symbol,omitempty"`
	SymbolNative *string `json:"symbol_native,omitempty"`
}

// Dividend defines model for Dividend.
type Dividend struct {
	Date     string  `json:"date"`
	Dividend float32 `json:"dividend"`
	Symbol   string  `json:"symbol"`
}

// EodPrice defines model for EodPrice.
type EodPrice struct {
	AdjClose    float32   `json:"adj_close"`
	AdjHigh     float32   `json:"adj_high"`
	AdjLow      float32   `json:"adj_low"`
	AdjOpen     float32   `json:"adj_open"`
	AdjVolume   float32   `json:"adj_volume"`
	Close       *float32  `json:"close,omitempty"`
	Date        time.Time `json:"date"`
	Dividend    float32   `json:"dividend"`
	Exchange    string    `json:"exchange"`
	High        float32   `json:"high"`
	Last        *float32  `json:"last,omitempty"`
	Low         float32   `json:"low"`
	Open        float32   `json:"open"`
	SplitFactor float32   `json:"split_factor"`
	Symbol      string    `json:"symbol"`
	Volume      *float32  `json:"volume,omitempty"`
}

// Error defines model for Error.
type Error struct {
	// Code An enumeration.
	Code    ErrorCode               `json:"code"`
	Context *map[string]interface{} `json:"context,omitempty"`
	Message string                  `json:"message"`
}

// ErrorCode An enumeration.
type ErrorCode = interface{}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error Error `json:"error"`
}

// Exchange defines model for Exchange.
type Exchange struct {
	Acronym     string             `json:"acronym"`
	City        string             `json:"city"`
	Country     string             `json:"country"`
	CountryCode string             `json:"country_code"`
	Currency    *Exchange_Currency `json:"currency,omitempty"`
	Mic         string             `json:"mic"`
	Name        string             `json:"name"`
	Timezone    *Exchange_Timezone `json:"timezone,omitempty"`
	Website     string             `json:"website"`
}

// Exchange_Currency defines model for Exchange.Currency.
type Exchange_Currency struct {
	union json.RawMessage
}

// Exchange_Timezone defines model for Exchange.Timezone.
type Exchange_Timezone struct {
	union json.RawMessage
}

// ExchangeBase defines model for ExchangeBase.
type ExchangeBase struct {
	Acronym     string  `json:"acronym"`
	City        string  `json:"city"`
	Country     string  `json:"country"`
	CountryCode *string `json:"country_code,omitempty"`
	Mic         string  `json:"mic"`
	Name        string  `json:"name"`
	Website     string  `json:"website"`
}

// ExchangeEod defines model for ExchangeEod.
type ExchangeEod struct {
	Acronym     string     `json:"acronym"`
	City        string     `json:"city"`
	Country     string     `json:"country"`
	CountryCode *string    `json:"country_code,omitempty"`
	Eod         []EodPrice `json:"eod"`
	Mic         string     `json:"mic"`
	Name        string     `json:"name"`
	Website     string     `json:"website"`
}

// ExchangeIntraday defines model for ExchangeIntraday.
type ExchangeIntraday struct {
	Acronym     string          `json:"acronym"`
	City        string          `json:"city"`
	Country     string          `json:"country"`
	CountryCode *string         `json:"country_code,omitempty"`
	Intraday    []IntervalPrice `json:"intraday"`
	Mic         string          `json:"mic"`
	Name        string          `json:"name"`
	Website     string          `json:"website"`
}

// ExchangeSymbol defines model for ExchangeSymbol.
type ExchangeSymbol struct {
	HasEod      bool   `json:"has_eod"`
	HasIntraday bool   `json:"has_intraday"`
	Name        string `json:"name"`
	Symbol      string `json:"symbol"`
}

// ExchangeTickers defines model for ExchangeTickers.
type ExchangeTickers struct {
	Acronym     string           `json:"acronym"`
	City        string           `json:"city"`
	Country     string           `json:"country"`
	CountryCode *string          `json:"country_code,omitempty"`
	Mic         string           `json:"mic"`
	Name        string           `json:"name"`
	Tickers     []ExchangeSymbol `json:"tickers"`
	Website     string           `json:"website"`
}

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// Interval An enumeration.
type Interval = interface{}

// IntervalPrice defines model for IntervalPrice.
type IntervalPrice struct {
	Close    *float32  `json:"close,omitempty"`
	Date     time.Time `json:"date"`
	Exchange string    `json:"exchange"`
	High     float32   `json:"high"`
	Last     *float32  `json:"last,omitempty"`
	Low      float32   `json:"low"`
	Open     float32   `json:"open"`
	Symbol   string    `json:"symbol"`
	Volume   *float32  `json:"volume,omitempty"`
}

// Nullable An enumeration.
type Nullable = interface{}

// PagedResponseExchangeEod defines model for PagedResponse_ExchangeEod_.
type PagedResponseExchangeEod struct {
	Data       ExchangeEod `json:"data"`
	Pagination Pagination  `json:"pagination"`
}

// PagedResponseExchangeIntraday defines model for PagedResponse_ExchangeIntraday_.
type PagedResponseExchangeIntraday struct {
	Data       ExchangeIntraday `json:"data"`
	Pagination Pagination       `json:"pagination"`
}

// PagedResponseExchangeTickers defines model for PagedResponse_ExchangeTickers_.
type PagedResponseExchangeTickers struct {
	Data       ExchangeTickers `json:"data"`
	Pagination Pagination      `json:"pagination"`
}

// PagedResponseListModelsCurrency defines model for PagedResponse_List_models.Currency__.
type PagedResponseListModelsCurrency struct {
	Data       []Currency `json:"data"`
	Pagination Pagination `json:"pagination"`
}

// PagedResponseListModelsDividend defines model for PagedResponse_List_models.Dividend__.
type PagedResponseListModelsDividend struct {
	Data       []Dividend `json:"data"`
	Pagination Pagination `json:"pagination"`
}

// PagedResponseListModelsEodPrice defines model for PagedResponse_List_models.EodPrice__.
type PagedResponseListModelsEodPrice struct {
	Data       []EodPrice `json:"data"`
	Pagination Pagination `json:"pagination"`
}

// PagedResponseListModelsExchange defines model for PagedResponse_List_models.Exchange__.
type PagedResponseListModelsExchange struct {
	Data       []Exchange `json:"data"`
	Pagination Pagination `json:"pagination"`
}

// PagedResponseListModelsIntervalPrice defines model for PagedResponse_List_models.IntervalPrice__.
type PagedResponseListModelsIntervalPrice struct {
	Data       []IntervalPrice `json:"data"`
	Pagination Pagination      `json:"pagination"`
}

// PagedResponseListModelsSplit defines model for PagedResponse_List_models.Split__.
type PagedResponseListModelsSplit struct {
	Data       []Split    `json:"data"`
	Pagination Pagination `json:"pagination"`
}

// PagedResponseListModelsTicker defines model for PagedResponse_List_models.Ticker__.
type PagedResponseListModelsTicker struct {
	Data       []Ticker   `json:"data"`
	Pagination Pagination `json:"pagination"`
}

// PagedResponseListModelsTimezone defines model for PagedResponse_List_models.Timezone__.
type PagedResponseListModelsTimezone struct {
	Data       []Timezone `json:"data"`
	Pagination Pagination `json:"pagination"`
}

// PagedResponseTickerEod defines model for PagedResponse_TickerEod_.
type PagedResponseTickerEod struct {
	Data       TickerEod  `json:"data"`
	Pagination Pagination `json:"pagination"`
}

// PagedResponseTickerIntraday defines model for PagedResponse_TickerIntraday_.
type PagedResponseTickerIntraday struct {
	Data       TickerIntraday `json:"data"`
	Pagination Pagination     `json:"pagination"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	Count  int `json:"count"`
	Limit  int `json:"limit"`
	Offset int `json:"offset"`
	Total  int `json:"total"`
}

// Sort An enumeration.
type Sort = interface{}

// Split defines model for Split.
type Split struct {
	Date        string  `json:"date"`
	SplitFactor float32 `json:"split_factor"`
	Symbol      string  `json:"symbol"`
}

// Ticker defines model for Ticker.
type Ticker struct {
	Country       string       `json:"country"`
	HasEod        bool         `json:"has_eod"`
	HasIntraday   bool         `json:"has_intraday"`
	Name          string       `json:"name"`
	StockExchange ExchangeBase `json:"stock_exchange"`
	Symbol        string       `json:"symbol"`
}

// TickerEod defines model for TickerEod.
type TickerEod struct {
	Country     string     `json:"country"`
	Eod         []EodPrice `json:"eod"`
	HasEod      bool       `json:"has_eod"`
	HasIntraday bool       `json:"has_intraday"`
	Name        string     `json:"name"`
	Symbol      string     `json:"symbol"`
}

// TickerIntraday defines model for TickerIntraday.
type TickerIntraday struct {
	Country     string          `json:"country"`
	HasEod      bool            `json:"has_eod"`
	HasIntraday bool            `json:"has_intraday"`
	Intraday    []IntervalPrice `json:"intraday"`
	Name        string          `json:"name"`
	Symbol      string          `json:"symbol"`
}

// Timezone defines model for Timezone.
type Timezone struct {
	Abbr     string `json:"abbr"`
	AbbrDst  string `json:"abbr_dst"`
	Timezone string `json:"timezone"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []ValidationError_Loc_Item `json:"loc"`
	Msg  string                     `json:"msg"`
	Type string                     `json:"type"`
}

// ValidationErrorLoc0 defines model for .
type ValidationErrorLoc0 = string

// ValidationErrorLoc1 defines model for .
type ValidationErrorLoc1 = int

// ValidationError_Loc_Item defines model for ValidationError.loc.Item.
type ValidationError_Loc_Item struct {
	union json.RawMessage
}

// CurrenciesParams defines parameters for Currencies.
type CurrenciesParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
	Limit     *int   `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *int   `form:"offset,omitempty" json:"offset,omitempty"`
}

// DividendsParams defines parameters for Dividends.
type DividendsParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
	Symbols   string `form:"symbols" json:"symbols"`
	Sort      *Sort  `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// EodParams defines parameters for Eod.
type EodParams struct {
	AccessKey string  `form:"access_key" json:"access_key"`
	Symbols   string  `form:"symbols" json:"symbols"`
	Exchange  *string `form:"exchange,omitempty" json:"exchange,omitempty"`
	Sort      *Sort   `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// EodLatestParams defines parameters for EodLatest.
type EodLatestParams struct {
	AccessKey string  `form:"access_key" json:"access_key"`
	Symbols   string  `form:"symbols" json:"symbols"`
	Exchange  *string `form:"exchange,omitempty" json:"exchange,omitempty"`
	Sort      *Sort   `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// EodDateParams defines parameters for EodDate.
type EodDateParams struct {
	AccessKey string  `form:"access_key" json:"access_key"`
	Symbols   string  `form:"symbols" json:"symbols"`
	Exchange  *string `form:"exchange,omitempty" json:"exchange,omitempty"`
	Sort      *Sort   `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// ExchangesParams defines parameters for Exchanges.
type ExchangesParams struct {
	AccessKey string  `form:"access_key" json:"access_key"`
	Search    *string `form:"search,omitempty" json:"search,omitempty"`
	Limit     *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// ExchangeMicParams defines parameters for ExchangeMic.
type ExchangeMicParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
}

// ExchangeMicEodParams defines parameters for ExchangeMicEod.
type ExchangeMicEodParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
	Symbols   string `form:"symbols" json:"symbols"`
	Sort      *Sort  `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// ExchangeMicEodLatestParams defines parameters for ExchangeMicEodLatest.
type ExchangeMicEodLatestParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
	Symbols   string `form:"symbols" json:"symbols"`
}

// ExchangeMicEodDateParams defines parameters for ExchangeMicEodDate.
type ExchangeMicEodDateParams struct {
	Symbols   string `form:"symbols" json:"symbols"`
	AccessKey string `form:"access_key" json:"access_key"`
}

// ExchangeMicIntradayParams defines parameters for ExchangeMicIntraday.
type ExchangeMicIntradayParams struct {
	AccessKey string    `form:"access_key" json:"access_key"`
	Symbols   string    `form:"symbols" json:"symbols"`
	Interval  *Interval `form:"interval,omitempty" json:"interval,omitempty"`
	Sort      *Sort     `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// ExchangeMicIntradayLatestParams defines parameters for ExchangeMicIntradayLatest.
type ExchangeMicIntradayLatestParams struct {
	Symbols   string `form:"symbols" json:"symbols"`
	AccessKey string `form:"access_key" json:"access_key"`
}

// ExchangeMicIntradayDateParams defines parameters for ExchangeMicIntradayDate.
type ExchangeMicIntradayDateParams struct {
	Symbols   string `form:"symbols" json:"symbols"`
	AccessKey string `form:"access_key" json:"access_key"`
}

// ExchangeMicTickersParams defines parameters for ExchangeMicTickers.
type ExchangeMicTickersParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
}

// IntradayParams defines parameters for Intraday.
type IntradayParams struct {
	AccessKey string    `form:"access_key" json:"access_key"`
	Symbols   string    `form:"symbols" json:"symbols"`
	Exchange  *string   `form:"exchange,omitempty" json:"exchange,omitempty"`
	Sort      *Sort     `form:"sort,omitempty" json:"sort,omitempty"`
	Interval  *Interval `form:"interval,omitempty" json:"interval,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// IntradayLatestParams defines parameters for IntradayLatest.
type IntradayLatestParams struct {
	AccessKey string    `form:"access_key" json:"access_key"`
	Symbols   string    `form:"symbols" json:"symbols"`
	Exchange  *string   `form:"exchange,omitempty" json:"exchange,omitempty"`
	Sort      *Sort     `form:"sort,omitempty" json:"sort,omitempty"`
	Interval  *Interval `form:"interval,omitempty" json:"interval,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// IntradayDateParams defines parameters for IntradayDate.
type IntradayDateParams struct {
	AccessKey string    `form:"access_key" json:"access_key"`
	Symbols   string    `form:"symbols" json:"symbols"`
	Exchange  *string   `form:"exchange,omitempty" json:"exchange,omitempty"`
	Sort      *Sort     `form:"sort,omitempty" json:"sort,omitempty"`
	Interval  *Interval `form:"interval,omitempty" json:"interval,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// SplitsParams defines parameters for Splits.
type SplitsParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
	Symbols   string `form:"symbols" json:"symbols"`
	Sort      *Sort  `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// TickersParams defines parameters for Tickers.
type TickersParams struct {
	AccessKey string  `form:"access_key" json:"access_key"`
	Exchange  *string `form:"exchange,omitempty" json:"exchange,omitempty"`
	Search    *string `form:"search,omitempty" json:"search,omitempty"`
	Limit     *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// TickerSymbolParams defines parameters for TickerSymbol.
type TickerSymbolParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
}

// TickerSymbolDividendsParams defines parameters for TickerSymbolDividends.
type TickerSymbolDividendsParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
	Sort      *Sort  `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
}

// TickerSymbolEodParams defines parameters for TickerSymbolEod.
type TickerSymbolEodParams struct {
	AccessKey string  `form:"access_key" json:"access_key"`
	Exchange  *string `form:"exchange,omitempty" json:"exchange,omitempty"`
	Sort      *Sort   `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// TickerSymbolEodLatestParams defines parameters for TickerSymbolEodLatest.
type TickerSymbolEodLatestParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
}

// TickerSymbolEodDateParams defines parameters for TickerSymbolEodDate.
type TickerSymbolEodDateParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
}

// TickerSymbolIntradayParams defines parameters for TickerSymbolIntraday.
type TickerSymbolIntradayParams struct {
	AccessKey string    `form:"access_key" json:"access_key"`
	Exchange  *string   `form:"exchange,omitempty" json:"exchange,omitempty"`
	Sort      *Sort     `form:"sort,omitempty" json:"sort,omitempty"`
	Interval  *Interval `form:"interval,omitempty" json:"interval,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// TickerSymbolIntradayLatestParams defines parameters for TickerSymbolIntradayLatest.
type TickerSymbolIntradayLatestParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
}

// TickerSymbolIntradayDateParams defines parameters for TickerSymbolIntradayDate.
type TickerSymbolIntradayDateParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
}

// TickerSymbolSplitsParams defines parameters for TickerSymbolSplits.
type TickerSymbolSplitsParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
	Sort      *Sort  `form:"sort,omitempty" json:"sort,omitempty"`

	// DateFrom Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateFrom *string `form:"date_from,omitempty" json:"date_from,omitempty"`

	// DateTo Date in the formats %Y-%m-%d, %Y-%m-%d %H:%M:%S or ISO-8601 %Y-%m-%dT%H:%M:%S+%Z
	DateTo *string `form:"date_to,omitempty" json:"date_to,omitempty"`
}

// TimezonesParams defines parameters for Timezones.
type TimezonesParams struct {
	AccessKey string `form:"access_key" json:"access_key"`
	Limit     *int   `form:"limit,omitempty" json:"limit,omitempty"`
	Offset    *int   `form:"offset,omitempty" json:"offset,omitempty"`
}

// AsCurrency returns the union data inside the Exchange_Currency as a Currency
func (t Exchange_Currency) AsCurrency() (Currency, error) {
	var body Currency
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCurrency overwrites any union data inside the Exchange_Currency as the provided Currency
func (t *Exchange_Currency) FromCurrency(v Currency) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCurrency performs a merge with any union data inside the Exchange_Currency, using the provided Currency
func (t *Exchange_Currency) MergeCurrency(v Currency) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNullable returns the union data inside the Exchange_Currency as a Nullable
func (t Exchange_Currency) AsNullable() (Nullable, error) {
	var body Nullable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNullable overwrites any union data inside the Exchange_Currency as the provided Nullable
func (t *Exchange_Currency) FromNullable(v Nullable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNullable performs a merge with any union data inside the Exchange_Currency, using the provided Nullable
func (t *Exchange_Currency) MergeNullable(v Nullable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Exchange_Currency) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Exchange_Currency) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTimezone returns the union data inside the Exchange_Timezone as a Timezone
func (t Exchange_Timezone) AsTimezone() (Timezone, error) {
	var body Timezone
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTimezone overwrites any union data inside the Exchange_Timezone as the provided Timezone
func (t *Exchange_Timezone) FromTimezone(v Timezone) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTimezone performs a merge with any union data inside the Exchange_Timezone, using the provided Timezone
func (t *Exchange_Timezone) MergeTimezone(v Timezone) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNullable returns the union data inside the Exchange_Timezone as a Nullable
func (t Exchange_Timezone) AsNullable() (Nullable, error) {
	var body Nullable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNullable overwrites any union data inside the Exchange_Timezone as the provided Nullable
func (t *Exchange_Timezone) FromNullable(v Nullable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNullable performs a merge with any union data inside the Exchange_Timezone, using the provided Nullable
func (t *Exchange_Timezone) MergeNullable(v Nullable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Exchange_Timezone) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Exchange_Timezone) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsValidationErrorLoc0 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc0
func (t ValidationError_Loc_Item) AsValidationErrorLoc0() (ValidationErrorLoc0, error) {
	var body ValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc0 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) FromValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc0 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLoc1 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc1
func (t ValidationError_Loc_Item) AsValidationErrorLoc1() (ValidationErrorLoc1, error) {
	var body ValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc1 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) FromValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc1 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Currencies request
	Currencies(ctx context.Context, params *CurrenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Dividends request
	Dividends(ctx context.Context, params *DividendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Eod request
	Eod(ctx context.Context, params *EodParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EodLatest request
	EodLatest(ctx context.Context, params *EodLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EodDate request
	EodDate(ctx context.Context, date string, params *EodDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Exchanges request
	Exchanges(ctx context.Context, params *ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeMic request
	ExchangeMic(ctx context.Context, mic string, params *ExchangeMicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeMicEod request
	ExchangeMicEod(ctx context.Context, mic string, params *ExchangeMicEodParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeMicEodLatest request
	ExchangeMicEodLatest(ctx context.Context, mic string, params *ExchangeMicEodLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeMicEodDate request
	ExchangeMicEodDate(ctx context.Context, mic string, date string, params *ExchangeMicEodDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeMicIntraday request
	ExchangeMicIntraday(ctx context.Context, mic string, params *ExchangeMicIntradayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeMicIntradayLatest request
	ExchangeMicIntradayLatest(ctx context.Context, mic string, params *ExchangeMicIntradayLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeMicIntradayDate request
	ExchangeMicIntradayDate(ctx context.Context, mic string, date string, params *ExchangeMicIntradayDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeMicTickers request
	ExchangeMicTickers(ctx context.Context, mic string, params *ExchangeMicTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Intraday request
	Intraday(ctx context.Context, params *IntradayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IntradayLatest request
	IntradayLatest(ctx context.Context, params *IntradayLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IntradayDate request
	IntradayDate(ctx context.Context, date string, params *IntradayDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Splits request
	Splits(ctx context.Context, params *SplitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Tickers request
	Tickers(ctx context.Context, params *TickersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TickerSymbol request
	TickerSymbol(ctx context.Context, symbol string, params *TickerSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TickerSymbolDividends request
	TickerSymbolDividends(ctx context.Context, symbol string, params *TickerSymbolDividendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TickerSymbolEod request
	TickerSymbolEod(ctx context.Context, symbol string, params *TickerSymbolEodParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TickerSymbolEodLatest request
	TickerSymbolEodLatest(ctx context.Context, symbol string, params *TickerSymbolEodLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TickerSymbolEodDate request
	TickerSymbolEodDate(ctx context.Context, symbol string, date string, params *TickerSymbolEodDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TickerSymbolIntraday request
	TickerSymbolIntraday(ctx context.Context, symbol string, params *TickerSymbolIntradayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TickerSymbolIntradayLatest request
	TickerSymbolIntradayLatest(ctx context.Context, symbol string, params *TickerSymbolIntradayLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TickerSymbolIntradayDate request
	TickerSymbolIntradayDate(ctx context.Context, symbol string, date string, params *TickerSymbolIntradayDateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TickerSymbolSplits request
	TickerSymbolSplits(ctx context.Context, symbol string, params *TickerSymbolSplitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Timezones request
	Timezones(ctx context.Context, params *TimezonesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Currencies(ctx context.Context, params *CurrenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrenciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Dividends(ctx context.Context, params *DividendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDividendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Eod(ctx context.Context, params *EodParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEodRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EodLatest(ctx context.Context, params *EodLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEodLatestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EodDate(ctx context.Context, date string, params *EodDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEodDateRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Exchanges(ctx context.Context, params *ExchangesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeMic(ctx context.Context, mic string, params *ExchangeMicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeMicRequest(c.Server, mic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeMicEod(ctx context.Context, mic string, params *ExchangeMicEodParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeMicEodRequest(c.Server, mic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeMicEodLatest(ctx context.Context, mic string, params *ExchangeMicEodLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeMicEodLatestRequest(c.Server, mic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeMicEodDate(ctx context.Context, mic string, date string, params *ExchangeMicEodDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeMicEodDateRequest(c.Server, mic, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeMicIntraday(ctx context.Context, mic string, params *ExchangeMicIntradayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeMicIntradayRequest(c.Server, mic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeMicIntradayLatest(ctx context.Context, mic string, params *ExchangeMicIntradayLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeMicIntradayLatestRequest(c.Server, mic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeMicIntradayDate(ctx context.Context, mic string, date string, params *ExchangeMicIntradayDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeMicIntradayDateRequest(c.Server, mic, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeMicTickers(ctx context.Context, mic string, params *ExchangeMicTickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeMicTickersRequest(c.Server, mic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Intraday(ctx context.Context, params *IntradayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntradayRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntradayLatest(ctx context.Context, params *IntradayLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntradayLatestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IntradayDate(ctx context.Context, date string, params *IntradayDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIntradayDateRequest(c.Server, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Splits(ctx context.Context, params *SplitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSplitsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Tickers(ctx context.Context, params *TickersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TickerSymbol(ctx context.Context, symbol string, params *TickerSymbolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickerSymbolRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TickerSymbolDividends(ctx context.Context, symbol string, params *TickerSymbolDividendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickerSymbolDividendsRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TickerSymbolEod(ctx context.Context, symbol string, params *TickerSymbolEodParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickerSymbolEodRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TickerSymbolEodLatest(ctx context.Context, symbol string, params *TickerSymbolEodLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickerSymbolEodLatestRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TickerSymbolEodDate(ctx context.Context, symbol string, date string, params *TickerSymbolEodDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickerSymbolEodDateRequest(c.Server, symbol, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TickerSymbolIntraday(ctx context.Context, symbol string, params *TickerSymbolIntradayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickerSymbolIntradayRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TickerSymbolIntradayLatest(ctx context.Context, symbol string, params *TickerSymbolIntradayLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickerSymbolIntradayLatestRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TickerSymbolIntradayDate(ctx context.Context, symbol string, date string, params *TickerSymbolIntradayDateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickerSymbolIntradayDateRequest(c.Server, symbol, date, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TickerSymbolSplits(ctx context.Context, symbol string, params *TickerSymbolSplitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTickerSymbolSplitsRequest(c.Server, symbol, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Timezones(ctx context.Context, params *TimezonesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimezonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCurrenciesRequest generates requests for Currencies
func NewCurrenciesRequest(server string, params *CurrenciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/currencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDividendsRequest generates requests for Dividends
func NewDividendsRequest(server string, params *DividendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dividends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEodRequest generates requests for Eod
func NewEodRequest(server string, params *EodParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eod")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEodLatestRequest generates requests for EodLatest
func NewEodLatestRequest(server string, params *EodLatestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eod/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEodDateRequest generates requests for EodDate
func NewEodDateRequest(server string, date string, params *EodDateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eod/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangesRequest generates requests for Exchanges
func NewExchangesRequest(server string, params *ExchangesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeMicRequest generates requests for ExchangeMic
func NewExchangeMicRequest(server string, mic string, params *ExchangeMicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mic", runtime.ParamLocationPath, mic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeMicEodRequest generates requests for ExchangeMicEod
func NewExchangeMicEodRequest(server string, mic string, params *ExchangeMicEodParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mic", runtime.ParamLocationPath, mic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/eod", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeMicEodLatestRequest generates requests for ExchangeMicEodLatest
func NewExchangeMicEodLatestRequest(server string, mic string, params *ExchangeMicEodLatestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mic", runtime.ParamLocationPath, mic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/eod/latest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeMicEodDateRequest generates requests for ExchangeMicEodDate
func NewExchangeMicEodDateRequest(server string, mic string, date string, params *ExchangeMicEodDateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mic", runtime.ParamLocationPath, mic)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/eod/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeMicIntradayRequest generates requests for ExchangeMicIntraday
func NewExchangeMicIntradayRequest(server string, mic string, params *ExchangeMicIntradayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mic", runtime.ParamLocationPath, mic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/intraday", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeMicIntradayLatestRequest generates requests for ExchangeMicIntradayLatest
func NewExchangeMicIntradayLatestRequest(server string, mic string, params *ExchangeMicIntradayLatestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mic", runtime.ParamLocationPath, mic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/intraday/latest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeMicIntradayDateRequest generates requests for ExchangeMicIntradayDate
func NewExchangeMicIntradayDateRequest(server string, mic string, date string, params *ExchangeMicIntradayDateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mic", runtime.ParamLocationPath, mic)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/intraday/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExchangeMicTickersRequest generates requests for ExchangeMicTickers
func NewExchangeMicTickersRequest(server string, mic string, params *ExchangeMicTickersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mic", runtime.ParamLocationPath, mic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exchanges/%s/tickers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIntradayRequest generates requests for Intraday
func NewIntradayRequest(server string, params *IntradayParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/intraday")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIntradayLatestRequest generates requests for IntradayLatest
func NewIntradayLatestRequest(server string, params *IntradayLatestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/intraday/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIntradayDateRequest generates requests for IntradayDate
func NewIntradayDateRequest(server string, date string, params *IntradayDateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/intraday/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSplitsRequest generates requests for Splits
func NewSplitsRequest(server string, params *SplitsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/splits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbols", runtime.ParamLocationQuery, params.Symbols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickersRequest generates requests for Tickers
func NewTickersRequest(server string, params *TickersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickerSymbolRequest generates requests for TickerSymbol
func NewTickerSymbolRequest(server string, symbol string, params *TickerSymbolParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickerSymbolDividendsRequest generates requests for TickerSymbolDividends
func NewTickerSymbolDividendsRequest(server string, symbol string, params *TickerSymbolDividendsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s/dividends", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickerSymbolEodRequest generates requests for TickerSymbolEod
func NewTickerSymbolEodRequest(server string, symbol string, params *TickerSymbolEodParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s/eod", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickerSymbolEodLatestRequest generates requests for TickerSymbolEodLatest
func NewTickerSymbolEodLatestRequest(server string, symbol string, params *TickerSymbolEodLatestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s/eod/latest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickerSymbolEodDateRequest generates requests for TickerSymbolEodDate
func NewTickerSymbolEodDateRequest(server string, symbol string, date string, params *TickerSymbolEodDateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s/eod/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickerSymbolIntradayRequest generates requests for TickerSymbolIntraday
func NewTickerSymbolIntradayRequest(server string, symbol string, params *TickerSymbolIntradayParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s/intraday", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Exchange != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exchange", runtime.ParamLocationQuery, *params.Exchange); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Interval != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickerSymbolIntradayLatestRequest generates requests for TickerSymbolIntradayLatest
func NewTickerSymbolIntradayLatestRequest(server string, symbol string, params *TickerSymbolIntradayLatestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s/intraday/latest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickerSymbolIntradayDateRequest generates requests for TickerSymbolIntradayDate
func NewTickerSymbolIntradayDateRequest(server string, symbol string, date string, params *TickerSymbolIntradayDateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s/intraday/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTickerSymbolSplitsRequest generates requests for TickerSymbolSplits
func NewTickerSymbolSplitsRequest(server string, symbol string, params *TickerSymbolSplitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "symbol", runtime.ParamLocationPath, symbol)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tickers/%s/splits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_from", runtime.ParamLocationQuery, *params.DateFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DateTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_to", runtime.ParamLocationQuery, *params.DateTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTimezonesRequest generates requests for Timezones
func NewTimezonesRequest(server string, params *TimezonesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/timezones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "access_key", runtime.ParamLocationQuery, params.AccessKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CurrenciesWithResponse request
	CurrenciesWithResponse(ctx context.Context, params *CurrenciesParams, reqEditors ...RequestEditorFn) (*CurrenciesResponse, error)

	// DividendsWithResponse request
	DividendsWithResponse(ctx context.Context, params *DividendsParams, reqEditors ...RequestEditorFn) (*DividendsResponse, error)

	// EodWithResponse request
	EodWithResponse(ctx context.Context, params *EodParams, reqEditors ...RequestEditorFn) (*EodResponse, error)

	// EodLatestWithResponse request
	EodLatestWithResponse(ctx context.Context, params *EodLatestParams, reqEditors ...RequestEditorFn) (*EodLatestResponse, error)

	// EodDateWithResponse request
	EodDateWithResponse(ctx context.Context, date string, params *EodDateParams, reqEditors ...RequestEditorFn) (*EodDateResponse, error)

	// ExchangesWithResponse request
	ExchangesWithResponse(ctx context.Context, params *ExchangesParams, reqEditors ...RequestEditorFn) (*ExchangesResponse, error)

	// ExchangeMicWithResponse request
	ExchangeMicWithResponse(ctx context.Context, mic string, params *ExchangeMicParams, reqEditors ...RequestEditorFn) (*ExchangeMicResponse, error)

	// ExchangeMicEodWithResponse request
	ExchangeMicEodWithResponse(ctx context.Context, mic string, params *ExchangeMicEodParams, reqEditors ...RequestEditorFn) (*ExchangeMicEodResponse, error)

	// ExchangeMicEodLatestWithResponse request
	ExchangeMicEodLatestWithResponse(ctx context.Context, mic string, params *ExchangeMicEodLatestParams, reqEditors ...RequestEditorFn) (*ExchangeMicEodLatestResponse, error)

	// ExchangeMicEodDateWithResponse request
	ExchangeMicEodDateWithResponse(ctx context.Context, mic string, date string, params *ExchangeMicEodDateParams, reqEditors ...RequestEditorFn) (*ExchangeMicEodDateResponse, error)

	// ExchangeMicIntradayWithResponse request
	ExchangeMicIntradayWithResponse(ctx context.Context, mic string, params *ExchangeMicIntradayParams, reqEditors ...RequestEditorFn) (*ExchangeMicIntradayResponse, error)

	// ExchangeMicIntradayLatestWithResponse request
	ExchangeMicIntradayLatestWithResponse(ctx context.Context, mic string, params *ExchangeMicIntradayLatestParams, reqEditors ...RequestEditorFn) (*ExchangeMicIntradayLatestResponse, error)

	// ExchangeMicIntradayDateWithResponse request
	ExchangeMicIntradayDateWithResponse(ctx context.Context, mic string, date string, params *ExchangeMicIntradayDateParams, reqEditors ...RequestEditorFn) (*ExchangeMicIntradayDateResponse, error)

	// ExchangeMicTickersWithResponse request
	ExchangeMicTickersWithResponse(ctx context.Context, mic string, params *ExchangeMicTickersParams, reqEditors ...RequestEditorFn) (*ExchangeMicTickersResponse, error)

	// IntradayWithResponse request
	IntradayWithResponse(ctx context.Context, params *IntradayParams, reqEditors ...RequestEditorFn) (*IntradayResponse, error)

	// IntradayLatestWithResponse request
	IntradayLatestWithResponse(ctx context.Context, params *IntradayLatestParams, reqEditors ...RequestEditorFn) (*IntradayLatestResponse, error)

	// IntradayDateWithResponse request
	IntradayDateWithResponse(ctx context.Context, date string, params *IntradayDateParams, reqEditors ...RequestEditorFn) (*IntradayDateResponse, error)

	// SplitsWithResponse request
	SplitsWithResponse(ctx context.Context, params *SplitsParams, reqEditors ...RequestEditorFn) (*SplitsResponse, error)

	// TickersWithResponse request
	TickersWithResponse(ctx context.Context, params *TickersParams, reqEditors ...RequestEditorFn) (*TickersResponse, error)

	// TickerSymbolWithResponse request
	TickerSymbolWithResponse(ctx context.Context, symbol string, params *TickerSymbolParams, reqEditors ...RequestEditorFn) (*TickerSymbolResponse, error)

	// TickerSymbolDividendsWithResponse request
	TickerSymbolDividendsWithResponse(ctx context.Context, symbol string, params *TickerSymbolDividendsParams, reqEditors ...RequestEditorFn) (*TickerSymbolDividendsResponse, error)

	// TickerSymbolEodWithResponse request
	TickerSymbolEodWithResponse(ctx context.Context, symbol string, params *TickerSymbolEodParams, reqEditors ...RequestEditorFn) (*TickerSymbolEodResponse, error)

	// TickerSymbolEodLatestWithResponse request
	TickerSymbolEodLatestWithResponse(ctx context.Context, symbol string, params *TickerSymbolEodLatestParams, reqEditors ...RequestEditorFn) (*TickerSymbolEodLatestResponse, error)

	// TickerSymbolEodDateWithResponse request
	TickerSymbolEodDateWithResponse(ctx context.Context, symbol string, date string, params *TickerSymbolEodDateParams, reqEditors ...RequestEditorFn) (*TickerSymbolEodDateResponse, error)

	// TickerSymbolIntradayWithResponse request
	TickerSymbolIntradayWithResponse(ctx context.Context, symbol string, params *TickerSymbolIntradayParams, reqEditors ...RequestEditorFn) (*TickerSymbolIntradayResponse, error)

	// TickerSymbolIntradayLatestWithResponse request
	TickerSymbolIntradayLatestWithResponse(ctx context.Context, symbol string, params *TickerSymbolIntradayLatestParams, reqEditors ...RequestEditorFn) (*TickerSymbolIntradayLatestResponse, error)

	// TickerSymbolIntradayDateWithResponse request
	TickerSymbolIntradayDateWithResponse(ctx context.Context, symbol string, date string, params *TickerSymbolIntradayDateParams, reqEditors ...RequestEditorFn) (*TickerSymbolIntradayDateResponse, error)

	// TickerSymbolSplitsWithResponse request
	TickerSymbolSplitsWithResponse(ctx context.Context, symbol string, params *TickerSymbolSplitsParams, reqEditors ...RequestEditorFn) (*TickerSymbolSplitsResponse, error)

	// TimezonesWithResponse request
	TimezonesWithResponse(ctx context.Context, params *TimezonesParams, reqEditors ...RequestEditorFn) (*TimezonesResponse, error)
}

type CurrenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsCurrency
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CurrenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DividendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsDividend
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DividendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DividendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsEodPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EodLatestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsEodPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EodLatestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EodLatestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EodDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsEodPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EodDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EodDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsExchange
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeMicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Exchange
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeMicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeMicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeMicEodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseExchangeEod
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeMicEodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeMicEodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeMicEodLatestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseExchangeEod
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeMicEodLatestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeMicEodLatestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeMicEodDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseExchangeEod
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeMicEodDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeMicEodDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeMicIntradayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseExchangeIntraday
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeMicIntradayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeMicIntradayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeMicIntradayLatestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseExchangeIntraday
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeMicIntradayLatestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeMicIntradayLatestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeMicIntradayDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseExchangeIntraday
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeMicIntradayDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeMicIntradayDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeMicTickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseExchangeTickers
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExchangeMicTickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeMicTickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IntradayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsIntervalPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IntradayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IntradayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IntradayLatestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsIntervalPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IntradayLatestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IntradayLatestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IntradayDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsIntervalPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r IntradayDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IntradayDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SplitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsSplit
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SplitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SplitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsTicker
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickerSymbolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ticker
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickerSymbolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickerSymbolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickerSymbolDividendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsDividend
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickerSymbolDividendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickerSymbolDividendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickerSymbolEodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseTickerEod
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickerSymbolEodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickerSymbolEodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickerSymbolEodLatestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EodPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickerSymbolEodLatestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickerSymbolEodLatestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickerSymbolEodDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EodPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickerSymbolEodDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickerSymbolEodDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickerSymbolIntradayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseTickerIntraday
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickerSymbolIntradayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickerSymbolIntradayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickerSymbolIntradayLatestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntervalPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickerSymbolIntradayLatestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickerSymbolIntradayLatestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickerSymbolIntradayDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsIntervalPrice
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickerSymbolIntradayDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickerSymbolIntradayDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TickerSymbolSplitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsSplit
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TickerSymbolSplitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TickerSymbolSplitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimezonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagedResponseListModelsTimezone
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *HTTPValidationError
	JSON429      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r TimezonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimezonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CurrenciesWithResponse request returning *CurrenciesResponse
func (c *ClientWithResponses) CurrenciesWithResponse(ctx context.Context, params *CurrenciesParams, reqEditors ...RequestEditorFn) (*CurrenciesResponse, error) {
	rsp, err := c.Currencies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrenciesResponse(rsp)
}

// DividendsWithResponse request returning *DividendsResponse
func (c *ClientWithResponses) DividendsWithResponse(ctx context.Context, params *DividendsParams, reqEditors ...RequestEditorFn) (*DividendsResponse, error) {
	rsp, err := c.Dividends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDividendsResponse(rsp)
}

// EodWithResponse request returning *EodResponse
func (c *ClientWithResponses) EodWithResponse(ctx context.Context, params *EodParams, reqEditors ...RequestEditorFn) (*EodResponse, error) {
	rsp, err := c.Eod(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEodResponse(rsp)
}

// EodLatestWithResponse request returning *EodLatestResponse
func (c *ClientWithResponses) EodLatestWithResponse(ctx context.Context, params *EodLatestParams, reqEditors ...RequestEditorFn) (*EodLatestResponse, error) {
	rsp, err := c.EodLatest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEodLatestResponse(rsp)
}

// EodDateWithResponse request returning *EodDateResponse
func (c *ClientWithResponses) EodDateWithResponse(ctx context.Context, date string, params *EodDateParams, reqEditors ...RequestEditorFn) (*EodDateResponse, error) {
	rsp, err := c.EodDate(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEodDateResponse(rsp)
}

// ExchangesWithResponse request returning *ExchangesResponse
func (c *ClientWithResponses) ExchangesWithResponse(ctx context.Context, params *ExchangesParams, reqEditors ...RequestEditorFn) (*ExchangesResponse, error) {
	rsp, err := c.Exchanges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangesResponse(rsp)
}

// ExchangeMicWithResponse request returning *ExchangeMicResponse
func (c *ClientWithResponses) ExchangeMicWithResponse(ctx context.Context, mic string, params *ExchangeMicParams, reqEditors ...RequestEditorFn) (*ExchangeMicResponse, error) {
	rsp, err := c.ExchangeMic(ctx, mic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeMicResponse(rsp)
}

// ExchangeMicEodWithResponse request returning *ExchangeMicEodResponse
func (c *ClientWithResponses) ExchangeMicEodWithResponse(ctx context.Context, mic string, params *ExchangeMicEodParams, reqEditors ...RequestEditorFn) (*ExchangeMicEodResponse, error) {
	rsp, err := c.ExchangeMicEod(ctx, mic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeMicEodResponse(rsp)
}

// ExchangeMicEodLatestWithResponse request returning *ExchangeMicEodLatestResponse
func (c *ClientWithResponses) ExchangeMicEodLatestWithResponse(ctx context.Context, mic string, params *ExchangeMicEodLatestParams, reqEditors ...RequestEditorFn) (*ExchangeMicEodLatestResponse, error) {
	rsp, err := c.ExchangeMicEodLatest(ctx, mic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeMicEodLatestResponse(rsp)
}

// ExchangeMicEodDateWithResponse request returning *ExchangeMicEodDateResponse
func (c *ClientWithResponses) ExchangeMicEodDateWithResponse(ctx context.Context, mic string, date string, params *ExchangeMicEodDateParams, reqEditors ...RequestEditorFn) (*ExchangeMicEodDateResponse, error) {
	rsp, err := c.ExchangeMicEodDate(ctx, mic, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeMicEodDateResponse(rsp)
}

// ExchangeMicIntradayWithResponse request returning *ExchangeMicIntradayResponse
func (c *ClientWithResponses) ExchangeMicIntradayWithResponse(ctx context.Context, mic string, params *ExchangeMicIntradayParams, reqEditors ...RequestEditorFn) (*ExchangeMicIntradayResponse, error) {
	rsp, err := c.ExchangeMicIntraday(ctx, mic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeMicIntradayResponse(rsp)
}

// ExchangeMicIntradayLatestWithResponse request returning *ExchangeMicIntradayLatestResponse
func (c *ClientWithResponses) ExchangeMicIntradayLatestWithResponse(ctx context.Context, mic string, params *ExchangeMicIntradayLatestParams, reqEditors ...RequestEditorFn) (*ExchangeMicIntradayLatestResponse, error) {
	rsp, err := c.ExchangeMicIntradayLatest(ctx, mic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeMicIntradayLatestResponse(rsp)
}

// ExchangeMicIntradayDateWithResponse request returning *ExchangeMicIntradayDateResponse
func (c *ClientWithResponses) ExchangeMicIntradayDateWithResponse(ctx context.Context, mic string, date string, params *ExchangeMicIntradayDateParams, reqEditors ...RequestEditorFn) (*ExchangeMicIntradayDateResponse, error) {
	rsp, err := c.ExchangeMicIntradayDate(ctx, mic, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeMicIntradayDateResponse(rsp)
}

// ExchangeMicTickersWithResponse request returning *ExchangeMicTickersResponse
func (c *ClientWithResponses) ExchangeMicTickersWithResponse(ctx context.Context, mic string, params *ExchangeMicTickersParams, reqEditors ...RequestEditorFn) (*ExchangeMicTickersResponse, error) {
	rsp, err := c.ExchangeMicTickers(ctx, mic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeMicTickersResponse(rsp)
}

// IntradayWithResponse request returning *IntradayResponse
func (c *ClientWithResponses) IntradayWithResponse(ctx context.Context, params *IntradayParams, reqEditors ...RequestEditorFn) (*IntradayResponse, error) {
	rsp, err := c.Intraday(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntradayResponse(rsp)
}

// IntradayLatestWithResponse request returning *IntradayLatestResponse
func (c *ClientWithResponses) IntradayLatestWithResponse(ctx context.Context, params *IntradayLatestParams, reqEditors ...RequestEditorFn) (*IntradayLatestResponse, error) {
	rsp, err := c.IntradayLatest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntradayLatestResponse(rsp)
}

// IntradayDateWithResponse request returning *IntradayDateResponse
func (c *ClientWithResponses) IntradayDateWithResponse(ctx context.Context, date string, params *IntradayDateParams, reqEditors ...RequestEditorFn) (*IntradayDateResponse, error) {
	rsp, err := c.IntradayDate(ctx, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIntradayDateResponse(rsp)
}

// SplitsWithResponse request returning *SplitsResponse
func (c *ClientWithResponses) SplitsWithResponse(ctx context.Context, params *SplitsParams, reqEditors ...RequestEditorFn) (*SplitsResponse, error) {
	rsp, err := c.Splits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSplitsResponse(rsp)
}

// TickersWithResponse request returning *TickersResponse
func (c *ClientWithResponses) TickersWithResponse(ctx context.Context, params *TickersParams, reqEditors ...RequestEditorFn) (*TickersResponse, error) {
	rsp, err := c.Tickers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickersResponse(rsp)
}

// TickerSymbolWithResponse request returning *TickerSymbolResponse
func (c *ClientWithResponses) TickerSymbolWithResponse(ctx context.Context, symbol string, params *TickerSymbolParams, reqEditors ...RequestEditorFn) (*TickerSymbolResponse, error) {
	rsp, err := c.TickerSymbol(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickerSymbolResponse(rsp)
}

// TickerSymbolDividendsWithResponse request returning *TickerSymbolDividendsResponse
func (c *ClientWithResponses) TickerSymbolDividendsWithResponse(ctx context.Context, symbol string, params *TickerSymbolDividendsParams, reqEditors ...RequestEditorFn) (*TickerSymbolDividendsResponse, error) {
	rsp, err := c.TickerSymbolDividends(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickerSymbolDividendsResponse(rsp)
}

// TickerSymbolEodWithResponse request returning *TickerSymbolEodResponse
func (c *ClientWithResponses) TickerSymbolEodWithResponse(ctx context.Context, symbol string, params *TickerSymbolEodParams, reqEditors ...RequestEditorFn) (*TickerSymbolEodResponse, error) {
	rsp, err := c.TickerSymbolEod(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickerSymbolEodResponse(rsp)
}

// TickerSymbolEodLatestWithResponse request returning *TickerSymbolEodLatestResponse
func (c *ClientWithResponses) TickerSymbolEodLatestWithResponse(ctx context.Context, symbol string, params *TickerSymbolEodLatestParams, reqEditors ...RequestEditorFn) (*TickerSymbolEodLatestResponse, error) {
	rsp, err := c.TickerSymbolEodLatest(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickerSymbolEodLatestResponse(rsp)
}

// TickerSymbolEodDateWithResponse request returning *TickerSymbolEodDateResponse
func (c *ClientWithResponses) TickerSymbolEodDateWithResponse(ctx context.Context, symbol string, date string, params *TickerSymbolEodDateParams, reqEditors ...RequestEditorFn) (*TickerSymbolEodDateResponse, error) {
	rsp, err := c.TickerSymbolEodDate(ctx, symbol, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickerSymbolEodDateResponse(rsp)
}

// TickerSymbolIntradayWithResponse request returning *TickerSymbolIntradayResponse
func (c *ClientWithResponses) TickerSymbolIntradayWithResponse(ctx context.Context, symbol string, params *TickerSymbolIntradayParams, reqEditors ...RequestEditorFn) (*TickerSymbolIntradayResponse, error) {
	rsp, err := c.TickerSymbolIntraday(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickerSymbolIntradayResponse(rsp)
}

// TickerSymbolIntradayLatestWithResponse request returning *TickerSymbolIntradayLatestResponse
func (c *ClientWithResponses) TickerSymbolIntradayLatestWithResponse(ctx context.Context, symbol string, params *TickerSymbolIntradayLatestParams, reqEditors ...RequestEditorFn) (*TickerSymbolIntradayLatestResponse, error) {
	rsp, err := c.TickerSymbolIntradayLatest(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickerSymbolIntradayLatestResponse(rsp)
}

// TickerSymbolIntradayDateWithResponse request returning *TickerSymbolIntradayDateResponse
func (c *ClientWithResponses) TickerSymbolIntradayDateWithResponse(ctx context.Context, symbol string, date string, params *TickerSymbolIntradayDateParams, reqEditors ...RequestEditorFn) (*TickerSymbolIntradayDateResponse, error) {
	rsp, err := c.TickerSymbolIntradayDate(ctx, symbol, date, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickerSymbolIntradayDateResponse(rsp)
}

// TickerSymbolSplitsWithResponse request returning *TickerSymbolSplitsResponse
func (c *ClientWithResponses) TickerSymbolSplitsWithResponse(ctx context.Context, symbol string, params *TickerSymbolSplitsParams, reqEditors ...RequestEditorFn) (*TickerSymbolSplitsResponse, error) {
	rsp, err := c.TickerSymbolSplits(ctx, symbol, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTickerSymbolSplitsResponse(rsp)
}

// TimezonesWithResponse request returning *TimezonesResponse
func (c *ClientWithResponses) TimezonesWithResponse(ctx context.Context, params *TimezonesParams, reqEditors ...RequestEditorFn) (*TimezonesResponse, error) {
	rsp, err := c.Timezones(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimezonesResponse(rsp)
}

// ParseCurrenciesResponse parses an HTTP response from a CurrenciesWithResponse call
func ParseCurrenciesResponse(rsp *http.Response) (*CurrenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsCurrency
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDividendsResponse parses an HTTP response from a DividendsWithResponse call
func ParseDividendsResponse(rsp *http.Response) (*DividendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DividendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsDividend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEodResponse parses an HTTP response from a EodWithResponse call
func ParseEodResponse(rsp *http.Response) (*EodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsEodPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEodLatestResponse parses an HTTP response from a EodLatestWithResponse call
func ParseEodLatestResponse(rsp *http.Response) (*EodLatestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EodLatestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsEodPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEodDateResponse parses an HTTP response from a EodDateWithResponse call
func ParseEodDateResponse(rsp *http.Response) (*EodDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EodDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsEodPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangesResponse parses an HTTP response from a ExchangesWithResponse call
func ParseExchangesResponse(rsp *http.Response) (*ExchangesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsExchange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangeMicResponse parses an HTTP response from a ExchangeMicWithResponse call
func ParseExchangeMicResponse(rsp *http.Response) (*ExchangeMicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeMicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Exchange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangeMicEodResponse parses an HTTP response from a ExchangeMicEodWithResponse call
func ParseExchangeMicEodResponse(rsp *http.Response) (*ExchangeMicEodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeMicEodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseExchangeEod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangeMicEodLatestResponse parses an HTTP response from a ExchangeMicEodLatestWithResponse call
func ParseExchangeMicEodLatestResponse(rsp *http.Response) (*ExchangeMicEodLatestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeMicEodLatestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseExchangeEod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangeMicEodDateResponse parses an HTTP response from a ExchangeMicEodDateWithResponse call
func ParseExchangeMicEodDateResponse(rsp *http.Response) (*ExchangeMicEodDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeMicEodDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseExchangeEod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangeMicIntradayResponse parses an HTTP response from a ExchangeMicIntradayWithResponse call
func ParseExchangeMicIntradayResponse(rsp *http.Response) (*ExchangeMicIntradayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeMicIntradayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseExchangeIntraday
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangeMicIntradayLatestResponse parses an HTTP response from a ExchangeMicIntradayLatestWithResponse call
func ParseExchangeMicIntradayLatestResponse(rsp *http.Response) (*ExchangeMicIntradayLatestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeMicIntradayLatestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseExchangeIntraday
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangeMicIntradayDateResponse parses an HTTP response from a ExchangeMicIntradayDateWithResponse call
func ParseExchangeMicIntradayDateResponse(rsp *http.Response) (*ExchangeMicIntradayDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeMicIntradayDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseExchangeIntraday
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExchangeMicTickersResponse parses an HTTP response from a ExchangeMicTickersWithResponse call
func ParseExchangeMicTickersResponse(rsp *http.Response) (*ExchangeMicTickersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeMicTickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseExchangeTickers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIntradayResponse parses an HTTP response from a IntradayWithResponse call
func ParseIntradayResponse(rsp *http.Response) (*IntradayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IntradayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsIntervalPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIntradayLatestResponse parses an HTTP response from a IntradayLatestWithResponse call
func ParseIntradayLatestResponse(rsp *http.Response) (*IntradayLatestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IntradayLatestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsIntervalPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIntradayDateResponse parses an HTTP response from a IntradayDateWithResponse call
func ParseIntradayDateResponse(rsp *http.Response) (*IntradayDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IntradayDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsIntervalPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSplitsResponse parses an HTTP response from a SplitsWithResponse call
func ParseSplitsResponse(rsp *http.Response) (*SplitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SplitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsSplit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickersResponse parses an HTTP response from a TickersWithResponse call
func ParseTickersResponse(rsp *http.Response) (*TickersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsTicker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickerSymbolResponse parses an HTTP response from a TickerSymbolWithResponse call
func ParseTickerSymbolResponse(rsp *http.Response) (*TickerSymbolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickerSymbolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ticker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickerSymbolDividendsResponse parses an HTTP response from a TickerSymbolDividendsWithResponse call
func ParseTickerSymbolDividendsResponse(rsp *http.Response) (*TickerSymbolDividendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickerSymbolDividendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsDividend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickerSymbolEodResponse parses an HTTP response from a TickerSymbolEodWithResponse call
func ParseTickerSymbolEodResponse(rsp *http.Response) (*TickerSymbolEodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickerSymbolEodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseTickerEod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickerSymbolEodLatestResponse parses an HTTP response from a TickerSymbolEodLatestWithResponse call
func ParseTickerSymbolEodLatestResponse(rsp *http.Response) (*TickerSymbolEodLatestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickerSymbolEodLatestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EodPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickerSymbolEodDateResponse parses an HTTP response from a TickerSymbolEodDateWithResponse call
func ParseTickerSymbolEodDateResponse(rsp *http.Response) (*TickerSymbolEodDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickerSymbolEodDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EodPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickerSymbolIntradayResponse parses an HTTP response from a TickerSymbolIntradayWithResponse call
func ParseTickerSymbolIntradayResponse(rsp *http.Response) (*TickerSymbolIntradayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickerSymbolIntradayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseTickerIntraday
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickerSymbolIntradayLatestResponse parses an HTTP response from a TickerSymbolIntradayLatestWithResponse call
func ParseTickerSymbolIntradayLatestResponse(rsp *http.Response) (*TickerSymbolIntradayLatestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickerSymbolIntradayLatestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntervalPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickerSymbolIntradayDateResponse parses an HTTP response from a TickerSymbolIntradayDateWithResponse call
func ParseTickerSymbolIntradayDateResponse(rsp *http.Response) (*TickerSymbolIntradayDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickerSymbolIntradayDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsIntervalPrice
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTickerSymbolSplitsResponse parses an HTTP response from a TickerSymbolSplitsWithResponse call
func ParseTickerSymbolSplitsResponse(rsp *http.Response) (*TickerSymbolSplitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TickerSymbolSplitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsSplit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTimezonesResponse parses an HTTP response from a TimezonesWithResponse call
func ParseTimezonesResponse(rsp *http.Response) (*TimezonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimezonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagedResponseListModelsTimezone
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
